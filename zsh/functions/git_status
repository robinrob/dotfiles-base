IFS="
"

function line_contains_file {
  line=$1
  if $(is_file_or_dir $(print $line | gawk '{print $NF}')) || $(string_contains $line 'deleted:')
  then
    return 0
  else
    return 1
  fi
}

function get_file_from_line {
  remove_trailing_slash $(print $line | gawk '{print $NF}')
}


function get_file_status {
  file=$1

  git status --short $file | gawk '{print $1}'
}

function print_file_line {
  local +r RawLine=$1
  local +r FileStatus=$(get_file_status $(get_file_from_line $line))

  case $FileStatus in
    M) line="$(red $RawLine)" ;;
    D) line="$(red $RawLine)" ;;
    N) line="$(red $RawLine)" ;;
    ??) line="$(red $RawLine)" ;;
    A) line="$(green $RawLine)" ;;
  esac

  print "$line $(blue \($item_num\))"
}

if (( $# > 0 ))
then
  local +r FilenameOrNum=$1
  if [[ -n $FilenameOrNum ]] && is_number $FilenameOrNum > /dev/null
  then
    git_do_by_item_num 'git status' $FilenameOrNum
  else
    git status $*
  fi
else
  local item_num=1
  # Read all lines from command output INCLUDING newlines
  for line in "${(@f)"$(git status)"}"
  do
    if line_contains_file $line
    then
      print_file_line $line $index
      # print "$(red $line) $(blue \($item_num\))"

      item_num=$(( item_num + 1 ))
    elif string_contains $line 'new file:'
    then
      green $line
    else
      print $line
    fi
  done
fi
